#
# Copyright 2020 Apple Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from dataclasses import dataclass
import warnings

from dnikit.base import Producer, Introspector
from dnikit.exceptions import DNIKitException
from dnikit._logging import _Logged
from dnikit._availability import _pandas_available, _matplotlib_available
import dnikit.typing._types as t
import dnikit.typing._dnikit_types as dt

from ._recommendation import PFARecipe, PFAEnergyDiagnostics, PFAKLDiagnostics
from ._covariances_calculator import PFACovariancesResult, _prepare_covariances
from . import _pfa_algorithms
from ._pfa_algorithms import PFAStrategyType
from . import _pfa_units
from ._pfa_units import PFAUnitSelectionStrategyType

try:
    from pandas import DataFrame as pdDataFrame
    import pandas as pd
except ImportError:
    pdDataFrame = None
    pd = None

try:
    import matplotlib as mpl
    from matplotlib.axes import Axes as mplAxes
except ImportError:
    mpl = None
    mplAxes = None


@t.final
@dataclass(frozen=True)
class PFA(Introspector, _Logged):
    """
    Like other :class:`introspectors <dnikit.base.Introspector>`, use
    :func:`PFA.introspect <introspect>` to instantiate.

    Use PFA to discover highly correlated filter, or more generically unit,
    responses within layers of a neural network. Exploit data to guide
    `network compression` in order to decrease inference time
    and memory footprint while improving generalization. See the DNIKit docs for more information.

    Args:
        failed_responses: do not instantiate ``PFA`` directly, use
            :func:`PFA.introspect <introspect>`
    """

    @t.final
    class Strategy:
        """
        Bundled PFA strategies.  To implement a custom strategy, see :class:`PFAStrategyType`.
        """
        KL: t.Final = _pfa_algorithms.KL
        Energy: t.Final = _pfa_algorithms.Energy
        Size: t.Final = _pfa_algorithms.Size

    @t.final
    class UnitSelectionStrategy:
        """
        Strategy for selecting the maximally correlated units.  To implement a custom
        strategy, see :class:`PFAUnitSelectionStrategyType`.
        """
        AbsMax: t.Final = _pfa_units.AbsMax
        AbsMin: t.Final = _pfa_units.AbsMin
        L1Max: t.Final = _pfa_units.L1Max
        L1Min: t.Final = _pfa_units.L1Min

        @classmethod
        def get_algos(cls) -> t.Iterable[PFAUnitSelectionStrategyType]:
            """
            Returns: a list of all registered unit selection strategies.
            """
            for member in dir(cls):
                if "_" not in member and member != "get_algos":
                    yield getattr(cls, member)()

    @t.final
    class VisType:
        """Type of visualization modality for PFA, available to visualize via :func:`PFA.show()`"""

        CHART: t.Final = 'chart'
        """Chart comparing recommended vs. original unit counts per layer"""

        TABLE: t.Final = 'table'
        """Table of all PFA result data"""

    failed_responses: t.Sequence[str]
    """
    The names of any responses that failed to generate output.  This caused by layers with
    insufficient data to support the analysis.
    """

    _covariance_result_by_response: t.Mapping[str, PFACovariancesResult]
    """a mapping from successful response name to PFACovariancesResult"""

    @staticmethod
    def introspect(producer: Producer, *,
                   batch_size: int = 32,
                   epsilon_inactive: float = 1e-8) -> 'PFA':
        """
        Perform Principal Filter Analysis on the responses
        (:attr:`fields <dnikit.base.Batch.fields>`) generated by the ``producer``.

        Caution:
            The responses generated by ``producer`` are assumed to be 2D (Batch x C).
            Thus it might be necessary to :class:`pipeline <dnikit.base.pipeline>` together
            the :class:`Producer <dnikit.base.Producer>` with a
            :class:`Processor <dnikit.processors.Processor>`
            (e.g., :class:`Pooler <dnikit.processors.Pooler>`), that transforms each individual
            response from multi-dimensional to mono-dimensional.

        Args:
            producer: The producer of the responses (in :attr:`fields <dnikit.base.Batch.fields>`)
                to be analyzed
            batch_size: **[keyword arg, optional]** the batch size to use when consuming the
                responses (via :attr:`batch.fields <dnikit.base.Batch.fields>`)
            epsilon_inactive: **[keyword arg, optional]** factor used to identify inactive units
                (whose ``var < epsilon_inactive * np.max(var)``)

        Returns:
            an instance of ``PFA`` that can generate :class:`PFARecipes <PFARecipe>` using
            a :class:`PFAStrategyType` (e.g., :class:`PFA.Strategy.KL`).
        """
        response_covariances = _prepare_covariances(batch_size, producer)

        # exclude responses that do not have enough data to support the covariance
        failed_responses = []
        successful_responses = {}

        for response_name, covariances_calculator in response_covariances.items():
            num_samples = covariances_calculator.get_count()
            num_features = covariances_calculator.get_original_output_counts()
            if num_samples >= num_features:
                successful_responses[response_name] = covariances_calculator
            else:
                warning_message = (
                    "Attempted to compute covariance of data matrix with "
                    "less data points than features (data_point#, feature#) "
                    f"= ({num_samples}, {num_features})"
                )
                warnings.warn(warning_message)
                failed_responses.append(response_name)

        # convert the good responses into `PFACovariancesResult`
        covariance_result_by_response = {
            response_name: covariances_calculator._get_result(epsilon_inactive=epsilon_inactive)
            for response_name, covariances_calculator in successful_responses.items()
        }

        return PFA(failed_responses, covariance_result_by_response)

    def get_recipe(self, *, strategy: t.Optional[PFAStrategyType] = None,
                   unit_strategy: t.Optional[PFAUnitSelectionStrategyType] = None
                   ) -> t.Mapping[str, PFARecipe]:
        """
        Generate a recipe using the given algorithm and unit strategy.
        For more information refer to the `PFA` documentation page.

        Args:
            strategy: **[keyword arg, optional]** The algorithm to use, :class:`PFAStrategyType`.
                The default value is :class:`PFA.Strategy.KL`
            unit_strategy: **[keyword arg, optional]** the :class:`PFAUnitSelectionStrategyType`
                to use, default is :class:`PFA.UnitSelectionStrategy.L1Max`

        Returns:
            a mapping from response name to :class:`PFARecipe` for
            the given :class:`algorithm <Strategy>` and
            :class:`unit strategy <UnitSelectionStrategy>`.
        """
        if strategy is None:
            strategy = PFA.Strategy.KL()
        if unit_strategy is None:
            unit_strategy = PFA.UnitSelectionStrategy.L1Max()

        covariances = self._covariance_result_by_response

        # some algorithms optimize across all the responses so get the algorithm recipe first
        unfiltered_recipes = strategy(covariances)

        # then apply the per-response filter
        filtered_recipes = {
            name: recipe._apply_unit_result(
                list(unit_strategy(
                    covariances=covariances[name], num_units_to_keep=recipe.recommended_output_count
                ))
            )
            for name, recipe in unfiltered_recipes.items()
        }

        return filtered_recipes

    @property
    def _internal_result(self) -> t.Mapping[str, PFACovariancesResult]:
        """
        Access the internal PFACovariancesResult for each response.  This is useful for unit tests
        or inspecting the internals of the PFA algorithm.

        Returns:
            a mapping from successful response name to PFACovariancesResult
        """
        return self._covariance_result_by_response

    @staticmethod
    def _show_dataframe(recipe_result: t.Mapping[str, PFARecipe], *,
                        include_columns: t.Optional[t.Sequence[str]] = None,
                        exclude_columns: t.Optional[t.Sequence[str]] = None) -> pdDataFrame:
        """
        Create pandas dataframe of results to visualize in iPython / Jupyter notebook.
        Requires pandas, installed via `pandas` or `dnikit[notebook]`
        """
        if not _pandas_available():
            raise DNIKitException("PIL not available, was 'dnikit[notebook]' installed?")

        results = []

        for layer_name, recipe in recipe_result.items():
            # Create base result for a given layer from generic PFARecipe info
            layer_result = {
                "layer name": layer_name,
                "original count": recipe.original_output_count,
                "recommended count": recipe.recommended_output_count,
                "units to keep": (
                    set(range(recipe.original_output_count))
                    - set(recipe.maximally_correlated_units)
                ),
                "KL divergence": "N/A",
                "PFA strategy": "N/A",
                "units ratio": "N/A",
                "kept energy": "N/A"
            }

            # Add diagnostic info for PFA KL and PFA Energy
            if isinstance(recipe.diagnostics, PFAKLDiagnostics):
                layer_result['KL divergence'] = recipe.diagnostics.kl_divergence
                layer_result['PFA strategy'] = 'PFA KL'
                layer_result['units ratio'] = recipe.diagnostics.units_ratio
            elif isinstance(recipe.diagnostics, PFAEnergyDiagnostics):
                layer_result['PFA strategy'] = 'PFA Energy'
                layer_result['kept energy'] = recipe.diagnostics.total_kept_energy

            results.append(layer_result)

        pd_result = pdDataFrame(results)

        # Now prune returned columns based on `include_columns` and `exclude_columns` arguments
        column_titles = list(pd_result.columns)
        if include_columns is None:
            # Default to show these columns
            column_titles = ["layer name", "original count", "recommended count", "units to keep"]
        elif len(include_columns) > 0:
            column_titles = [
                title for title in include_columns
                if title in column_titles
            ]

        if exclude_columns is not None:
            column_titles = [title for title in column_titles if title not in exclude_columns]

        if not column_titles:
            # Could happen if exclude columns exactly equals include columns
            raise DNIKitException(
                "No columns selected, are the `exclude columns` the same as the ones to `include`"
            )

        return pd_result[column_titles]

    @staticmethod
    def _is_old_matplotlib_version(version_string: str) -> bool:
        parts = version_string.split('.')

        # check major and minor versions
        return int(parts[0]) <= 3 and int(parts[1]) <= 4

    @staticmethod
    def _show_chart(recipe_result: t.Mapping[str, PFARecipe]) -> mplAxes:
        """
        Chart a single PFA recipe comparing recommended output vs. original output counts

        Note: Requires matplotlib, installed via `matplotlib` or `dnikit[notebook]`

        Args:
            recipe_result: result of :func:`PFA.introspect`, mapping of layer to :class:`PFARecipe`

        Return:
            matplotlib pyplot axis of PFA results from input recipes
        """

        if not _matplotlib_available():
            raise DNIKitException("matplotlib not available, was 'dnikit[notebook]' installed?")

        # Collect data to plot from recipe
        compressed = []
        original = []
        names = []
        for name, r in recipe_result.items():
            compressed.append(r.recommended_output_count)
            original.append(r.original_output_count)
            names.append(name)

        # Plot original layer size vs. recommended (compressed) layer size
        fig, ax = mpl.pyplot.subplots(figsize=(15, 6))  # Create a figure and an axes.
        ax.plot(compressed, color='g', marker='o', label='compressed')
        ax.plot(original, color='blue', marker='o', label='original')
        if PFA._is_old_matplotlib_version(mpl.__version__):
            # Python 3.6 requires a lower version of matplotlib, which has a different API
            ax.set_xticks(range(len(names)))
            ax.set_xticklabels(names, rotation='vertical')
        else:
            ax.set_xticks(range(len(names)), names, rotation='vertical')
        ax.set_xlabel('layer name')
        ax.set_ylabel('number of units')
        ax.legend()
        ax.grid()

        return ax

    @staticmethod
    def show(recipe_result: dt.OneOrMany[t.Mapping[str, PFARecipe]], *,
             vis_type: str = VisType.TABLE,
             include_columns: t.Optional[t.Sequence[str]] = None,
             exclude_columns: t.Optional[t.Sequence[str]] = None,
             ) -> t.Union[mplAxes, pdDataFrame]:
        """
        Create table or chart to visualize PFA results in iPython / Jupyter notebook.

        Note: Requires `pandas <https://pandas.pydata.org/docs/>`_
        (``vis_type`` is :class:`PFA.VisType.TABLE`) or
        `matplotlib <https://matplotlib.org/stable/>`_
        (``vis_type`` is :class:`PFA.VisType.CHART`), which can be installed with
        ``pip install "dnikit[notebook]"``

        Args:
            recipe_result: result of :func:`pfa.get_recipe <PFA.get_recipe>`, mapping of layer
                to :class:`PFARecipe`.
                When plotting for ``vis_type`` :class:`PFA.VisType.TABLE`, a sequence
                of ``t.Mapping[str, PFARecipe]`` can be passed in to compare multiple results.
            vis_type: **[keyword arg, optional]** determines visualization type.
                :class:`PFA.VisType.TABLE` for pandas dataframe result or
                :class:`PFA.VisType.CHART` for matplotlib pyplot of recommended vs.
                original unit counts
            include_columns: **[keyword arg, optional]** For ``vis_type``
                as :class:`PFA.VisType.TABLE` only.
                If included, only return :class:`pandas.DataFrame` with
                these columns. Defaults to include all columns (value ``None``).
                Options are: [``layer name``, ``original count``, ``recommended count``,
                ``units to keep``, ``KL divergence``, ``PFA strategy``, ``units ratio``,
                ``kept energy``].
            exclude_columns: **[keyword arg, optional]** For ``vis_type``
                as :class:`PFA.VisType.TABLE` only.
                If included, return :class:`pandas.DataFrame` without these
                columns (irrelevant if ``include_columns`` is specified). Defaults to ``None``.
                Options are: [``layer name``, ``original count``, ``recommended count``,
                ``units to keep``, ``KL divergence``, ``PFA strategy``, ``units ratio``,
                ``kept energy``].

        Return:
            :class:`pandas.DataFrame` or :class:`matplotlib.axes.Axes` of PFA results
            from input ``recipe_result``
        """

        if isinstance(recipe_result, PFA):
            raise DNIKitException(
                "The output of `PFA.introspect` has been passed into `PFA.show()`. Please pass the "
                "output of `pfa.get_recipe` into `PFA.show()`. The default behavior can be used "
                "by calling: `pfa = PFA.introspect(); recipe = pfa.get_recipe(); PFA.show(recipe)`"
            )

        if recipe_result == {} or recipe_result == []:
            raise ValueError("`recipe_result` parameter input is emtpy")

        # This is a bit of mypy finessing, first defining the type and then assigning
        many_results: t.Sequence[t.Mapping[str, PFARecipe]]
        if isinstance(recipe_result, t.Mapping):
            many_results = [recipe_result]
        else:
            many_results = list(recipe_result)

        if vis_type == PFA.VisType.TABLE:
            # Concatenate results for multiple recipe results
            return pd.concat([
                PFA._show_dataframe(
                    single_result,
                    include_columns=include_columns,
                    exclude_columns=exclude_columns,
                )
                for single_result in many_results
            ], ignore_index=True)
        elif vis_type == PFA.VisType.CHART:
            if len(many_results) > 1:
                raise DNIKitException(
                    "Only one recipe's chart can be plotted at a time."
                    " Please pass only one recipe result for vis_type: `PFA.VisType.CHART`"
                )
            return PFA._show_chart(many_results[0])
        else:
            raise ValueError(
                'Unexpected input for parameter `vis_type`. Expected `PFA.VisType.CHART`'
                ' or `PFA.VisType.TABLE`'
            )
